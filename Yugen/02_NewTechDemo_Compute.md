---
title: YUGA
permalink: /Yugen/ComputeTechDemo
---

Our Renderer is very new and all 10 previous techdemos were ran on Graphics Queue and has Graphics work only.

I spent a few days adding multi-queue submission to YugenRendererBackend or as we like to call it **YRB**.

Also spent good amount of time completing our **SPVReflector** to deduce SPIR-V (generated by HLSL) DescriptorTypes.

Thanks to [this wiki page](https://github.com/Microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst#introduction) by **DirectXShaderCompiler**.

Finally YRB now has the feature to submit to different Queues and submit compute work and Put Cross-Queue Barriers.

Here is our 11th TechDemo which is updating **2 milion** cubes positions in a Compute Pass and Will Render them instanced in a Graphics Pass. 

<p align="center">
  <img src="https://raw.githubusercontent.com/Erfan-Ahmadi/erfan-ahmadi.github.io/master/images/Yugen/ComputeDemo.gif" alt="" width="800"/>
</p>

Also there is a flag to enable to either use Graphics or Compute Queue to see any difference, I didn't expect much difference due to several reasons:
1. The job is heavy but the CommandBuffer is actually light-weight(Dispatch+some setup) 
2. Our 2 passes are linear and dependant on eachother, so nothing good unless we try async compute in a more complex rendering pipeline.

```c++
#if USE_COMPUTE_QUEUE > 0
        YRB::ComputeQueue_Submit(si);
#else 
        YRB::GraphicsQueue_Submit(si);
#endif 
```

There seemed to be no difference as expected :)