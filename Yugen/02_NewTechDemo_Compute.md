---
layout: post
title: Compute Demo
permalink: /blog/Yugen/ComputeTechDemo
---

Our Renderer is very new and all 10 previous techdemos run on Graphics Queue and have Graphics work only.

I spent a few days adding multi-queue submission to YugenRendererBackend or as we like to call it **YRB**.

Also spent good amount of time completing our **SPVReflector** to deduce SPIR-V (generated by HLSL) DescriptorTypes.

Thanks to [this wiki page](https://github.com/Microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst#introduction) by **DirectXShaderCompiler**.

Finally YRB now has the feature to submit to different queues and submit compute work and put Cross-Queue barriers.

Here is our 11th TechDemo which is updating **2 milion** cubes positions in a Compute Pass and Will Render them instanced in a Graphics Pass. 

<p align="center">
<iframe width="1280" height="720" src="https://www.youtube.com/embed/79-HU8G9A00" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</p>

Also there is a flag to enable/disable using Graphics or Compute Queue, I didn't expect much difference due to several reasons:
1. The job is heavy but the CommandBuffer is actually light-weight (Dispatch+some setup) 
2. Our 2 passes are linear and dependant on eachother, so nothing good unless we try async compute in a more complex rendering pipeline.

```c++
#if USE_COMPUTE_QUEUE > 0
        YRB::ComputeQueue_Submit(si);
#else 
        YRB::GraphicsQueue_Submit(si);
#endif 
```

There seemed to be no difference as expected :)

Also make sure to checkout my other posts on [Yugen Engine](/blog/Yugen)
